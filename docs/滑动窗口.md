## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```java
class Solution {
    // 难点：
    // 1. 滑动窗口.  什么时候向右滑动？ // 2. 什么时候缩小窗口 left
    //    条件不满足的时候向右滑动,条件满足后，更新结果
    //    移动left左窗口,使条件不满足.(或者能否寻找到更优解)。自然会导致窗口更新(因为移动left，不满足，下次right将会移动)
    public int minSubArrayLen(int target, int[] nums) {
        if(nums.length == 1) {
            if (nums[0] != target) {
                return 0;
            } else {
                return 1;
            }
        }

        int left = 0;
        int right = 0;
        int len = nums.length;
        int ans = Integer.MAX_VALUE;
        int sum = 0;

        while(right < len) {
            sum += nums[right];
            right++;
            
            while (sum >= target && left < right) {
                ans = ans < (right - left) ? ans: (right - left);
                sum -= nums[left];
                left++;
            }
        }
        return ans == Integer.MAX_VALUE? 0: ans;
    }
}
```

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```java
class Solution {
    // 1. 暴力 
    // 2. dp (错误)
    // 3. 正确解法 （滑动窗口）
    //    窗口 维护期间 需O(1) 时间复杂度 判断 是否存在

    // asdwaksdw.  应该会存在 边界的case
    public int lengthOfLongestSubstring(String s) {
       if(s == null || s.length() == 0) return 0;

       int[] dp = new int[128];

       int left = 0;
       int right = 0;
       int len = s.length();
       int sum = 0;
       int ans = Integer.MIN_VALUE;

       while(right < len) {
           
           
           dp[s.charAt(right) - ' ']++;
           right++;

           if(dp[s.charAt(right-1) - ' '] == 1 && left < right) {
            ans = ans > (right - left)? ans: (right - left); 
           }

           while(dp[s.charAt(right - 1) - ' '] > 1 && left < right) {
               dp[s.charAt(left) - ' ']--;
               left++;
               if (dp[s.charAt(right - 1) - ' '] == 1) {
                ans = ans > (right - left)? ans: (right - left);
               } 
           }
       }

       return ans; 
    }
}
```









#### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) hard

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

```java
class MedianFinder {

    // 设计一个数据结构
    // 能够添加和找到当前加入元素的中位数
    // 难点：1. 可以被添加 无限个数，数被怎么存储下来呢？ 其实需要存吗？根本不需要
    //      
    //      2. addNum 进去的数，其实后续除了求中位数的时候会用到。其他多余的数
    //          其他时候，多余的数 不会被用到了。
    //      3. 每次添加一个元素，其实都要有序，其实这个时候就用到了堆。 堆这个数据结构能维持顺序。
    //      4. 不管后续数据怎么加，保证数据顺序往前流动？ 怎么做呢？
    //      5. 单个数字，leftmax， rightmin 其实是不合适的。 就得使用数据容器。
    //      6. int 都得先转double

    // 维护当前数据结构中的数字数量
    private int size = 0;

    // 左边 最大
    private int leftmax = 0;
    // 右边 最小
    private int rightmin = 0;

    /** initialize your data structure here. */
    public MedianFinder() {

    }
    
    public void addNum(int num) {
        ++this.size;
        if(this.size == 1) {
            leftmax = num;
        } else if (this.size == 2) {
            if (num >= leftmax) {
                rightmin = num;
            } else {
                int temp = leftmax;
                leftmax = num;
                rightmin = temp;
            }
           
        } else if (num > rightmin) {
            leftmax = rightmin;
            rightmin = num;
        } else {
            leftmax = leftmax >= num ? leftmax: num;
        }
    }
    
    public double findMedian() {
        if (size % 2 == 0) {
            return (double)(((double)leftmax + (double)rightmin) / 2);
        } else {
            return (double)(leftmax);
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```



以上是错误的。



正确的题解：

```
```







#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) hard

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

```java
class Solution {

    // 滑动窗口解法，应该是
    // 维持这个窗口
    // 每次 往右移动一个元素，窗口去掉一个元素
    // 怎么每次 在窗口里维持一个最大值 这个是主要难点:
    // 每次进来和出去一个元素，需要每次在当前区间重新比较得到当前窗口最大值
    // 单调队列，能在O(n)时间复杂度, 找到k 区间的最值
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || nums.length == 0) return new int[0];

        int[] ans = new int[nums.length - k + 1]; // 结果数组
        Deque<Integer> deuqe = new ArrayDeque<>(); // 双端队列

        for(int i = 0, j = 0; i < nums.length; i++) {
            // 队头是否在k 的范围内,不在就pop
            if (!deuqe.isEmpty() && i - deuqe.peek() >= k) {
                deuqe.poll(); // 弹出队头,维护最大值 在区间 [i - k - 1,i]内
            } 

            while(!deuqe.isEmpty() && nums[i] >= nums[deuqe.peekLast()]) {
                deuqe.pollLast();
            }
            deuqe.offer(i);

            if (i >= k -1) {
                ans[j++] = nums[deuqe.peek()];  // 小心漏答案
            }
        }
        return ans;
    }
}
```

