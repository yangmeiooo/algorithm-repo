## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```java
class Solution {
    // 难点：
    // 1. 滑动窗口.  什么时候向右滑动？ // 2. 什么时候缩小窗口 left
    //    条件不满足的时候向右滑动,条件满足后，更新结果
    //    移动left左窗口,使条件不满足.(或者能否寻找到更优解)。自然会导致窗口更新(因为移动left，不满足，下次right将会移动)
    public int minSubArrayLen(int target, int[] nums) {
        if(nums.length == 1) {
            if (nums[0] != target) {
                return 0;
            } else {
                return 1;
            }
        }

        int left = 0;
        int right = 0;
        int len = nums.length;
        int ans = Integer.MAX_VALUE;
        int sum = 0;

        while(right < len) {
            sum += nums[right];
            right++;
            
            while (sum >= target && left < right) {
                ans = ans < (right - left) ? ans: (right - left);
                sum -= nums[left];
                left++;
            }
        }
        return ans == Integer.MAX_VALUE? 0: ans;
    }
}
```







#### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) hard

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

```java
class MedianFinder {

    // 设计一个数据结构
    // 能够添加和找到当前加入元素的中位数
    // 难点：1. 可以被添加 无限个数，数被怎么存储下来呢？ 其实需要存吗？根本不需要
    //      
    //      2. addNum 进去的数，其实后续除了求中位数的时候会用到。其他多余的数
    //          其他时候，多余的数 不会被用到了。
    //      3. 每次添加一个元素，其实都要有序，其实这个时候就用到了堆。 堆这个数据结构能维持顺序。
    //      4. 不管后续数据怎么加，保证数据顺序往前流动？ 怎么做呢？
    //      5. 单个数字，leftmax， rightmin 其实是不合适的。 就得使用数据容器。
    //      6. int 都得先转double

    // 维护当前数据结构中的数字数量
    private int size = 0;

    // 左边 最大
    private int leftmax = 0;
    // 右边 最小
    private int rightmin = 0;

    /** initialize your data structure here. */
    public MedianFinder() {

    }
    
    public void addNum(int num) {
        ++this.size;
        if(this.size == 1) {
            leftmax = num;
        } else if (this.size == 2) {
            if (num >= leftmax) {
                rightmin = num;
            } else {
                int temp = leftmax;
                leftmax = num;
                rightmin = temp;
            }
           
        } else if (num > rightmin) {
            leftmax = rightmin;
            rightmin = num;
        } else {
            leftmax = leftmax >= num ? leftmax: num;
        }
    }
    
    public double findMedian() {
        if (size % 2 == 0) {
            return (double)(((double)leftmax + (double)rightmin) / 2);
        } else {
            return (double)(leftmax);
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```



以上是错误的。



正确的题解：

```
```







#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) hard

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

```java
class Solution {

    // 滑动窗口解法，应该是
    // 最小的时候，会扩大，大于的时候会缩小
    // 怎么才能很好的写出这个算法呢？？
    public int[] maxSlidingWindow(int[] nums, int k) {
        int max = Integer.MIN_VALUE:

        int l = -1;
        int r = 0;
        int len = nums.length;

        while(r < len && r - l <= k) { // 小于 继续while

                    // 看左边边界 l 先到合适范围。

                    // 再看右边范围

                    // 选出当前窗口的最大值

                    // 再移动右边一位

                    // 再缩小左边一位
        }
    }
}
```



```java
/*  
        处理不了，[1] k=1
        [1,-1] k=1
    */
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 1) return new int[]{nums[0]};
        int l = 0;
        int r = 0;
        int ans = nums[0];
        int len = nums.length;

        List<Integer> dp = new ArrayList<>();

        while(r < len) {

             //处理右边
            while(r + 1 < len && (r - l) <= (k - 1)) {
                r++;
                ans =  ans > nums[r] ? ans: nums[r];

                if (r - l == (k - 1)) {
                    dp.add(ans);
                } 
            }
            // 是否跳出
            if (r == len - 1) break;

             // 左边   
            while(l < r && r - l >= (k - 1)) {
                l ++;
            }
        }

        int size = dp.size();
        int[] ret = new int[size];
        for(int i = 0;i < size; i++) {
            ret[i] = dp.get(i);
        }

        return ret;
    }
```





优化题解：

单调队列 为啥能解决？？