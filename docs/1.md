## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

```java
 public int[] twoSum(int[] nums, int target) {
        //1. 第一遍遍历一个数 
        //2. 在第二遍遍历得时候寻找第2个数
        //时间复杂度是 O（n^2）


        // O(n) 就能找到
        // 利用加法特性
        // target 已知, 扫描1 遍 O(n)
        // 因为只存在一个有效答案， 在找到的时候跳出来即可
        Map<Integer, Integer> map = new HashMap<>();
        int[] arrs = new int[2];

        map.put(nums[0], 0);
        for(int i = 1;i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) {
                arrs[0] = map.get(target-nums[i]);
                arrs[1] = i;
                return arrs;
            }
            map.put(nums[i] , i);
        }
        return arrs;
    }
```





## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```java
class Solution {
    // 1. 暴力
    // 2. dp
    public int lengthOfLongestSubstring(String s) {
        int max = -1;
        if (s.equals("")){
            return 0;
        } else if (s.length() == 1) {
            
        }
        int[] nums = new int[128];
        int[] dp = new int[s.length()];
        Arrays.fill(dp, 1);
        nums[s.charAt(0) - '0'] = 1;
        // 暴力做法：
        // 维护一个数组， 然后呢 当以 i 为不重复字符的最后一位时
        // 计算 i - 1 之前最大值，是否出现过，如果没有出现 就+ 1， 出现过为1.
        // 暴力关键是： 计算到i时，不知道前面是否出现过。

       for (int i = 1; i < s.length(); i++) {
           if (nums[s.charAt(i) - '0'] == 0) {
               dp[i] = dp[i - 1] + 1;
               max = max < dp[i]? dp[i]: max;
           } 
       }
       return max;
    }
}
```



## [704. 二分查找](do)

```java
public int search(int[] nums, int target) {
        
        // 二分查找
        int l = 0;
        int r = nums.length - 1;
        while(l <= r) {
            int mid = (l + r) >>> 1;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return -1;
    }
```

## [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```java
 public int singleNumber(int[] nums) {
        // 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
        // 疯狂暗示  异或操作  b = a ^ a ^ b;    
        // 交换变量利用这个特性节省一个变量得空间
        int res = nums[0];
        for(int i = 1; i < nums.length; i++) {
            res = (res ^ nums[i]); 
        }
        return res;
    }
```

## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)



翻转一棵二叉树。

```java
 	// 交换函数
    // 后序交换
    public TreeNode invertTree(TreeNode root) {
        if (root == null ) return null;
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        
        root.left = right;
        root.right = left;
        return root;
    }
```

## [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)



给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

**进阶：**你能不将整数转为字符串来解决这个问题吗？

```java
 // 进阶：你能不将整数转为字符串来解决这个问题吗？
    // 思路1 ： 整数转 字符串， 从中间开始比较
    // 思路2 ： 从最后一位拿到，保存成字符，再转int 比较是否相等
    // 思路3 ： 中间数字开始对折 是否相等
    public boolean isPalindrome(int x) {
        if (x < 0 || (x > 0 && x % 10 == 0 )) return false;

        int revertNum = 0;
        while(x > revertNum) {
            revertNum = revertNum * 10 + (x % 10);
            x /= 10;
        }

        return x == revertNum || x == (revertNum / 10); // 对应 x == reverNum
                                                        // 和奇数位去掉最后一位是否相等
    }
```

## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)



难度简单390收藏分享切换为英文接收动态反馈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。


注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

提示：

1 <= x <= 9
最多调用100 次 push、pop、top 和 empty
每次调用 pop 和 top 都保证栈不为空


进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。

```java
class MyStack {

    LinkedList<Integer> a = new LinkedList<>();  // a 是备用栈
    LinkedList<Integer> b = new LinkedList<>();  // b 是实际栈

    public MyStack() {

    }
    
    public void push(int x) {
        b.add(x);
    }
    
    public int pop() {
        while(b.size() > 1) {
            a.add(b.poll());
        }
        // 重新add 回b
        while(!a.isEmpty()) {
            b.add(a.poll());
        }
        return b.poll();
    }
    
    public int top() {
        while(b.size() > 1) {
            a.add(b.poll());
        }
        return b.peek();
    }
    
    public boolean empty() {
        return b.isEmpty();
    }
}
```



总结： 思路1 ， 开辟2个队列，其中一个做备用队列。 当push 进a时，pop进备用队列，再每次从备用队列返回a主队列。

​			  思路2，一个队列，每次poll n-1 次，到队尾。top 每次取队头即可。每次需要用一个标识位来区分， top 和 pop 操作。
