#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**进阶：**递归算法很简单，你可以通过迭代算法完成吗？

```java
 // 前序遍历 ,添加 路径进去
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return list;

        list.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return list;
    }
```





```java
进阶写法：
  class Solution {

    private List<Integer> list = new ArrayList<>();

    // 进阶写法, 不用递归
    // 手动创建一个栈， 模拟系统栈
    public List<Integer> preorderTraversal(TreeNode root) {
       
       if(root == null) {
           return list;
       }

       Stack<TreeNode> stack = new Stack<>();
       stack.push(root);

       while(!stack.isEmpty()) {
           TreeNode curNode = stack.pop();
           list.add(curNode.val);
           if (curNode.right != null) {
               stack.push(curNode.right);
           }
           if (curNode.left != null) {
               stack.push(curNode.left);
           }
       }
       return list;
    }

}
		
```



#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？



```java
class Solution {

    private List<Integer> list = new ArrayList<>();
    // 中序遍历, 左右根
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) return list;

        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        
        while(!stack.isEmpty() || cur != null) {
            while(cur != null) {
                 stack.push(cur);
                 cur = cur.left;   
            }

            TreeNode curNode = stack.pop();
            list.add(curNode.val);

            if (curNode.right != null) {
               //stack.push(curNode.right);
                cur = curNode.right;
            }
        }
        return list;
    }
}
```







#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

给定一个二叉树，返回它的 *后序* 遍历。

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

两种中法：

一种是前序遍历的，倒序输出

```java
class Solution {

    private List<Integer> list = new ArrayList<>();

    public List<Integer> postorderTraversal(TreeNode root) {

        if (root == null) return list;

        Stack<TreeNode> stack = new Stack<>();

        stack.push(root);
        while(!stack.isEmpty()) {
            
            TreeNode curNode = stack.pop();
            list.add(curNode.val);

            if (curNode.left != null) {
                stack.push(curNode.left);
            }

            if (curNode.right != null) {
                stack.push(curNode.right);
            }
        }
        Collections.reverse(list);   // 根右左 ，倒序后， 左右根
       
        return list;
    }
}
```



方法二：

```java
class Solution {

    private List<Integer> list = new ArrayList<>();

    public List<Integer> postorderTraversal(TreeNode root) {

        if (root == null) return list;
        Stack<TreeNode> stack = new Stack<>();

        TreeNode cur =  root;     
        TreeNode pre = null;			// 代表上次访问过的点
    
        while(!stack.isEmpty()|| cur != null) {
            while(cur != null) {
                stack.push(cur);
                cur = cur.left;
            }  
            // 处理右边
            TreeNode node = stack.pop();
            if ((node.left == null && node.right == null) || (node.right == pre) ){
                list.add(node.val);
                pre = node;
            } else if (node.right == null) {
                list.add(node.val);
                pre = node;
            } 
            else if (node.right != null) {
                stack.push(node);
                cur = node.right;
            }
        }
        return list;
    }
}
```





#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第k大的节点。

```java
class Solution {
    
    private int ans, cur = 0;
    // 思路1:  直接存入数组，排序，取第k大，但是显然不太符合要求
    // 思路2:  二叉搜索树一个很重要的性质 ，中序遍历 是递增序列，
    // 而题目所求的 第k 大元素，代表 中序递减的第k 个就是所求的答案。
    // 通过中序遍历调整顺序，使遍历顺序是递减。 当访问到第K 个时就是题目所求的答案。
    public int kthLargest(TreeNode root, int k) {

        findR(root, k);
        return ans;
    }

    public void findR(TreeNode root, int k) {

        if (root.right != null) findR(root.right, k);
        if (++cur == k) {
            ans = root.val;
            return;
        }
        if (root.left != null) findR(root.left, k);
    }

}
```

